#!/usr/bin/env python3
import re
import tkinter as tk
from pathlib import Path
import argparse

def get_clipboard_content():
    root = tk.Tk()
    root.withdraw()  # Hide the tkinter window
    try:
        return root.clipboard_get()
    except tk.TclError:
        return None
    finally:
        root.destroy()

def parse_ssh_command(command):
    # Pattern to match SSH command components - now handles optional port
    # This pattern matches: ssh user@host with optional -p port and other flags
    pattern = r'ssh\s+([^@\s]+)@([^\s]+)(?:\s+.*)?'
    match = re.match(pattern, command)
    
    if not match:
        raise ValueError("Invalid SSH command format")
    
    user, host = match.groups()
    
    # Extract port if specified with -p flag
    port_pattern = r'-p\s+(\d+)'
    port_match = re.search(port_pattern, command)
    port = port_match.group(1) if port_match else '22'
    
    return {
        'user': user,
        'host': host,
        'port': port
    }

def generate_config_entry(ssh_info, alias=None):
    # Use alias if provided, otherwise use host
    host_name = alias if alias else ssh_info['host']
    
    # Only include Port line if it's not the default port 22
    port_line = f"    Port {ssh_info['port']}\n" if ssh_info['port'] != '22' else ""
    
    config_template = f"""Host {host_name}
    HostName {ssh_info['host']}
    User {ssh_info['user']}
{port_line}    IdentityFile ~/.ssh/id_ed25519.1
    # RemoteCommand none
    ForwardAgent yes
"""
    return config_template

def read_ssh_config():
    ssh_config_path = Path.home() / '.ssh' / 'config'
    if not ssh_config_path.exists():
        return ""
    with open(ssh_config_path, 'r') as f:
        return f.read()

def find_existing_entry(config_content, host_name):
    # Split config into blocks
    blocks = re.split(r'\n(?=Host\s)', config_content.strip())
    # Find block that matches the host name (could be IP or alias)
    for block in blocks:
        if block.startswith(f'Host {host_name}\n'):
            return block.strip()
    return None

def remove_existing_entry(config_content, host_name):
    # Split config into blocks
    blocks = re.split(r'\n(?=Host\s)', config_content.strip())
    # Filter out blocks that match the host name
    new_blocks = [block for block in blocks if not block.startswith(f'Host {host_name}\n')]
    # Join blocks back together
    return '\n\n'.join(block.rstrip() for block in new_blocks)

def main():
    parser = argparse.ArgumentParser(description='Generate SSH config entry')
    parser.add_argument('--command', '-c', help='SSH command string (overrides clipboard)')
    parser.add_argument('--alias', '-a', help='Alias for the SSH host')
    args = parser.parse_args()
    
    # Get SSH command from argument or clipboard
    if args.command:
        command = args.command
    else:
        command = get_clipboard_content()
        if not command:
            print("Error: Clipboard is empty and no command provided")
            return
    
    try:
        # Parse the SSH command
        ssh_info = parse_ssh_command(command)
        
        # Get alias from argument or prompt user
        alias = args.alias
        if not alias:
            alias = input(f"\nEnter an alias for {ssh_info['host']} (or press Enter to use the IP): ").strip()
            if not alias:
                alias = None
        
        # Determine the host name to use (alias or IP)
        host_name = alias if alias else ssh_info['host']
        
        # Generate config entry
        config_entry = generate_config_entry(ssh_info, alias)
        
        # Print the config entry
        print(f"\nParsed SSH command: {command.strip()}")
        print(f"User: {ssh_info['user']}, Host: {ssh_info['host']}, Port: {ssh_info['port']}")
        if alias:
            print(f"Alias: {alias}")
        print("\nGenerated SSH config entry:")
        print("-" * 40)
        print(config_entry)
        
        # Check for existing entry
        existing_config = read_ssh_config()
        existing_entry = find_existing_entry(existing_config, host_name)
        
        if existing_entry:
            print(f"\nWARNING: Found existing entry for '{host_name}':")
            print("-" * 40)
            print(existing_entry)
        
        # Optionally update SSH config file
        ssh_config_path = Path.home() / '.ssh' / 'config'
        should_update = input("\nWould you like to update your SSH config? (y/n): ").lower()
        
        if should_update == 'y':
            # Remove any existing entry for this host name
            new_config = remove_existing_entry(existing_config, host_name)
            
            # Add new entry at the beginning
            if new_config:
                new_config = config_entry + '\n\n' + new_config
            else:
                new_config = config_entry
            
            # Write back to file
            with open(ssh_config_path, 'w') as f:
                f.write(new_config + '\n')
            
            if existing_entry:
                print(f"Replaced existing entry in {ssh_config_path}")
            else:
                print(f"Added new entry to {ssh_config_path}")
        
    except ValueError as e:
        print(f"Error: {e}")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")

if __name__ == "__main__":
    main()
